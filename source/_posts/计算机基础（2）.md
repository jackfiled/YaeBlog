---
title: 计算机基础（2）
date: 2021-08-31 12:04:27
tags:
---

## 写在前面
本文是计算机基础的第二篇，主要介绍计算机程序的编写，运行等等。

<!--more-->

# 我们生活中的经验
在我们日常使用电脑的过程，常常是直接双击在桌面上的应用程序图标便开始运行了一个程序。<br>
那么在这个过程中，电脑做了些什么？

# 0 快捷方式与程序
>注意本文所说的电脑均为Windows10操作系统

>这里我以QQ为例

我们首先来研究一下桌面的这个图标

在图标上右键查看属性
![QQ快捷方式的属性](../img/屏幕截图%202021-08-31%20133113.png)
可以看出，在桌面上的这个文件是一个“快捷方式”，只是QQ这个程序留在桌面上的一个路牌，指向了它真身所在的地方
>C:\Program Files (x86)\Tencent\QQ\Bin\QQ.exe

那我们便去它真身所在的地方一探究竟。
![QQ程序所在文件夹](../img/屏幕截图%202021-08-31%20135118.png)
看着这197个文件和眼花缭乱的英文文件名，便知道我们已经找到了QQ程序的真身，<del>毕竟文件越多，法力越强</del>毕竟这个快捷方式让我们看见了今天的主角之一——.exe**可执行文件**。
![](../img/屏幕截图%202021-08-31%20135542.png)

众所周知，现在使用的电脑在底层其实都是亿大堆有开和关两个状态的开关电路，用数学语言来说，就是电脑可以储存、运算的都是二进制0和1的信息，这种语言也被称为机器语言。那么自然的，既然我们在双击qq.exe之后，电脑就可以自动开始运行QQ的程序，那这个可执行文件中存储的就是电脑可以读懂的二进制信息了，这也是它被称作**二进制文件**的原因。<br>
下面是机器语言一些示例：
```
指令部分：
0000 代表 加载（LOAD）
0001 代表 存储（STORE）
寄存器部分：
0000 代表寄存器 A
0001 代表寄存器 B
存储器部分：
000000000000 代表地址为 0 的存储器
000000000001 代表地址为 1 的存储器
000000010000 代表地址为 16 的存储器
100000000000 代表地址为 2^11 的存储器
```

总结一下，所有在电脑中可以直接执行的程序，都是以机器语言书写的二进制文件。

# 1程序的编写
看到这里，就会有好奇的同学问道：“既然电脑只认识二进制的文件，那么程序员在编程的时候且不是一直敲01010101010000011100110100010101100....”<br>
**确实**，在电脑出现的初期，初代程序员们就是这样和机器“交流”的。显然，<del>懒惰</del>聪明的程序员不会一直使用这种效率低下的方式编程。于是，**汇编语言**出现了。<br>   
汇编语言使用助记符来代替和表示特定机器语言的操作，也可以识别代表地址和常量的标签和符号。上面的这句话可能不太好读懂，我们举个例子。假设在机器语言的中“1001”代表将传入的两个数的值相加，现在我们几个已经被机器语言折磨得欲死欲仙的程序员坐在一个开个会，我们共同约定用“ADD”来代表“1001”，同时，我们还可以使用a, b,c...等字母及其组合来代表一个计算机中储存的值，这样就可以不必死记那一串串的010101010了。下面是一个汇编语言的示例：
```
.globl _start

.text
_start:
 movl $len, %edx
 movl $msg, %ecx
 movl $1, %ebx
 movl $4, %eax
 int $0x80

 movl $0, %ebx
 movl $1, %eax
 int $0x80
.data
msg:
 .ascii "Hello, world!\n"
 len = . - msg
```
虽然这样语言的可读性已经大大优于机器语言，但由于其比较低级，在现代的软件开发中仍显得复杂，因此在现在的软件开发中，汇编语言的
使用范围已经很小。同时由于汇编语言十分“低级”，可以直接操作硬件，在使用时占用的内存更少，运行速度更快，在一些时效性很高的程序
和大型程序的核心模块中仍有重要的用途。
>世间的一切都有其两面性，需要辩证的看待。

在编写完程序之后，并不能直接运行写好的源代码。很显然，汇编语言只是人类之间的约定，机器并没有参与，它也并不知道我们在那里乱写
了什么。于是，我们就需要一个名叫汇编器的程序，将我们用汇编语言下的指令，翻译为机器可以听懂的机器语言，这个过程被称为**汇编**。
汇编之后的程序便可以直接运行了。<br>
我们在上面也提到过，使用汇编语言编写程序也不是十分的方便。那汇编语言的接班人是谁？<br>
是**高级语言**。<br>
1957年，当时计算机界的带头大哥，蓝色巨人IBM为了简化程序的开发过程，提出了世界上第一门被正式采用并流传至今的高级语言：**Fortran**。
第二年，一门仍在被广泛使用的高级语言**LISP**出现。而后，**COBOL**， **ALGOL**等高级语言也接连出现。这四门语言或是沿用至今，或是对后来的高级语言产生了深远的影响。<br>
在此后的十年中，不断的有高级语言出现，却也在不断的消失，虽然他们如今并不耳熟能详，但他们的出现都或多或少的帮助了一位重量级的选手。<br>
1969年到1973年，贝尔实验室的两位高人，丹尼斯·里奇，肯·汤普逊，开发了**C语言**。这门语言我们耳熟能详， 也是最近25年间使用广泛的编程语言。<br>
既然C语言是应用十分广泛的语言，那我们便以其为例来讲讲如何用高级语言编写程序。

# 2程序编写实例
我们先写一个简单的程序，用Windows自带记事本就可以。
>据说在这个程序员的世界中，高手都是用记事本编写程序的。

```
#include<stdio.h>
int main(void)
{
    printf("Hello, world!\n");
    return 0;
}
```
保存为hello.c,这便是一个简单的C程序源码。<br>
![没有描述](../img/屏幕截图%202021-09-02%20160742.png)
打开命令行界面（这个的介绍详见计算机基础（1），我们这里使用GNU计划开发的gcc编译器，先输入
```
gcc -v
```
确认已经安装了gcc编译器，已经安装的输出如下：
![gcc编译器](../img/屏幕截图%202021-09-02%20154323.png)
在确认安装之后，我们开始编译，输入
```
gcc hello.c -O hello.exe
```
>这里的“-O”指的是指定生成可执行文件的名称

编译完成，我们可以用ls命令发现，目录下已经生成了一个hello.exe文件
![编译完成的鸭子](../img/屏幕截图%202021-09-02%20155210.png)
我们使用
```
.\hello.exe
```
运行这个文件
![运行的结果](../img/屏幕截图%202021-09-02%20155346.png)
可以看见，我们花10秒钟编写的程序已经正确的输出了“hello， world！”<br>
显然高级语言的编写方式的远远优于汇编语言和机器语言的。

# 3编译器干了啥？
在我们亲生体验了用C语言写代码之后，相信同学们已经发现了，编译器在这个过程中发挥了举足轻重的作用。它将只有人类才看得懂的文字转化为了只有
电脑可以顺畅理解的机器语言，那么在编译的过程中，编译器都做了什么？<br>
下面我们就简单介绍一下编译器的工作过程。<br>
>总所周知，简单一般都代表漏洞百出。

一般来说，在我们键入“gcc”编译命令之后，编译器会进行四个步骤。<br>

### 0 预处理
在这个过程中，编译器会将程序中涉及的头文件添加进源代码中。这里的技术细节请自学C语言，大噶意思就是让你可以直接使用别人已经实现的一些功能。<br>

### 1 编译
在这一步，编译器会首先检查代码的规范性和代码中是否存在错误。若没发现错误，编译器便会将上一步提供的代码转换为以汇编语言写成的文件。
<br>

### 2 汇编
编译器的工作进行到这里，便会将上一步生成的汇编代码转换为以机器语言书写的二进制文件。
<br>

### 3链接
到这一步，一个名叫链接器的程序上场。简单的讲，链接器的工作就是解析未定义的符号引用，将目标文件中的占位符替换为符号的地址。链接器还要完成程序中各目标文件的地址空间的组织，这可能涉及重定位工作。
>不懂没关系，我也不太懂得起。

在这一步，便会生成可以执行的文件了。<br>

# 4反编译
在我们日常使用软件的过程中，我们往往只能拿到经过编译之后的二进制文件，但有时出于各种各样的原因，我们希望得到软件的源代码，
进行学习或者再次开发。那么在只有只有二进制文件的情况下，我们可以通过某种方式拿到源代码吗？<br>
有，这种方式被称为反编译，顾名思义，这是编译的反过程。
>注意：反编译某些商业软件可能是违反当地法律的。

但由于各种编程语言的不同，并不是所有的语言都有可以使用的反编译器。按照维基百科的说法：
```
The success of decompilation depends on the amount of information present in the code being decompiled and the sophistication of the analysis performed on it. The bytecode formats used by many virtual machines (such as the Java Virtual Machine or the .NET Framework Common Language Runtime) often include extensive metadata and high-level features that make decompilation quite feasible. The presence of debug data can make it possible to reproduce the original variable and structure names and even the line numbers. Machine language without such metadata or debug data is much harder to decompile.
```
反编译是否成功主要依赖于编译后的代码保留的源代码中信息的数量。一些基于一些虚拟机的编程语言，比如Java和.net就可以被很好的反编译。但是
比如像C和C++之类的C系列编程语言，它们编译之后的代码中并没有关于类，函数，变量的“元信息”，因次，就没有适合反编译C系语言的反编译器。即使
有，其反编译之后的代码也不是人类可以直接理解的，需要自己进行重写。<br>

# 5各种编程语言之介绍
在这篇文章中，我花了大量的篇幅利用C语言为例子，介绍了一个程序从编写到运行的全过程。但是，随着计算机技术的发展，已经有不少优秀的语言出现。
下面两张图展示了在本文写作的时候，世界上不同编程语言的流行程度。
![TIOBE](../img/屏幕截图%202021-09-04%20210544.png)
![PYPL](../img/屏幕截图%202021-09-04%20210646.png)
我们便选几个编程语言来简单介绍一下。<br>











